{"version":3,"sources":["webpack/bootstrap 4cf232788d486a4374bb","./frontend/twitter.js","./frontend/follow_toggle.js","./frontend/users_search.js","./frontend/tweet_compose.js"],"names":[],"mappings":";AAAA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAe;AACf;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;;;;;;ACtCA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;;AAEH;AACA;AACA,IAAG;AACH,EAAC,E;;;;;;ACjBD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAoB;AACpB;;AAEA,MAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,sBAAqB,YAAY;AACjC;AACA;AACA;AACA;AACA;AACA;AACA,MAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;;AAGA,+BAA8B,8B;;;;;;AC9D9B;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,UAAS,yBAAyB;AAClC;AACA,IAAG;AACH;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mBAAkB;;AAElB;;AAEA,gDAA+C,QAAQ;AACvD;;AAEA;;AAEA;AACA;AACA;AACA,QAAO;AACP;AACA;AACA;AACA,MAAK;AACL;AACA;;;;AAIA;AACA;AACA;AACA;;;AAGA,8B;;;;;;;ACjEA;AACA;AACA;AACA;;AAEA;;;AAGA;AACA;;AAEA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,yDAAwD,gBAAgB;AACxE,IAAG;AACH,6DAA4D,gBAAgB;;AAE5E;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,wCAAuC;AACvC,iD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,IAAG;AACH;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;;;;;AAMA;AACA;AACA;AACA;;;AAGA,+B","file":"bundle.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId])\n \t\t\treturn installedModules[moduleId].exports;\n\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\texports: {},\n \t\t\tid: moduleId,\n \t\t\tloaded: false\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.loaded = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(0);\n\n\n\n// WEBPACK FOOTER //\n// webpack/bootstrap 4cf232788d486a4374bb","const FollowToggle = require('./follow_toggle');\nconst UsersSearch = require('./users_search');\nconst TweetCompose = require('./tweet_compose');\n\n// Document ready callback \n$(()=> {\n $('.follow-toggle').each((i, button) => {\n\t    new FollowToggle(button);\n\t });\n\n  $('.users-search').each((i, search) => {\n\t    new UsersSearch(search);\n\t });\n\n  $('.tweet-compose').each((i, post) => {\n    new TweetCompose(post);\n\t });\n}); \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./frontend/twitter.js\n// module id = 0\n// module chunks = 0","class FollowToggle {\n  constructor(el){\n    this.el = $(el);\n    this.userId= this.el.data('user-id');\n    this.followState = this.el.data('initial-follow-state') \n    this.render();\n\n    this.el.click(this.handleClick.bind(this));\n  }\n\n    handleClick(event) {\n    event.preventDefault();\n\n    if (this.followState === \"followed\") {\n      this.followState = \"unfollowing\";\n      this.render(); // \"\"\n      this.makeRequest(\"DELETE\", \"unfollowed\")\n\n    } else if (this.followState === \"unfollowed\") {\n      this.followState = \"following\";\n      this.render();\n      this.makeRequest(\"POST\", \"followed\")\n    }\n  }\n\n  makeRequest(type, followState){\n    const that = this;\n    $.ajax({\n      url: `/users/${this.userId}/follow`,\n      dataType: \"json\",\n      method: type,\n      success() {\n        that.followState = followState;\n        that.render();\n      }\n    });\n  }\n\n  render() {\n    switch(this.followState){\n      case \"followed\":\n        this.el.prop(\"disabled\", false);\n        this.el.html(\"Unfollow!\");\n        break;\n      case \"unfollowed\":\n        this.el.prop(\"disabled\", false);\n        this.el.html(\"Follow!\");\n        break;\n      case \"following\":\n        this.el.prop(\"disabled\", true);\n        this.el.html(\"Following...\");\n        break;\n      case \"unfollowing\":\n        this.el.prop(\"disabled\", true);\n        this.el.html(\"Unfollowing...\");\n        break;\n    }\n  }\n\n}\n\n\nmodule.exports = FollowToggle; // this makes it require-able\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./frontend/follow_toggle.js\n// module id = 1\n// module chunks = 0","const FollowToggle = require('./follow_toggle.js');\n\nclass UsersSearch{\n\tconstructor(el){\n\t\tthis.el = $(el);\n    this.input = this.el.find(\"input[name=username]\");\n    this.ul = this.el.find(\".users\");\n\n    this.input.on(\"input\", this.handleInput.bind(this));\n}\n\n// Write a UsersSearch#handleInput handler. On each input event, make an AJAX request to \n// /users/search, sending the input's val as the query parameter. You can send query \n// parameters along with an $.ajax call through the data option. Don't forget to set \n// dataType!\nhandleInput(event){\n\n\tif (this.input.val() === \"\"){\n\t\tthis.renderResults([]);\n\t\treturn;\n\t}\n\n\t$.ajax({\n\t\turl: '/users/search', \n\t\tdataType: 'json',\n\t\tmethod: 'GET',\n\t\tdata: { query: this.input.val()},\n\t\tsuccess: this.renderResults.bind(this)\n\t\t});\n\t}\n\n// Last, we want to add follow toggle buttons for \n// each of these results. When building the li tags\n // for each user, build a button, too. \n\n // You can create a FollowToggle instance for the button to setup the follow toggle.\n\n\trenderResults(users){\n\t\tthis.ul.empty(); // same as .html(\"\") but faster\n\n\t\t$(users).each((i, user) =>{\n\t\t\t\n\t\t\tlet a = $('<a></a>').attr('href', `/users/${user.id}`).html(user.username);\n\t\t\tlet li = $('<li></li>');\n\n      let followButton = $('<button></button');\n\n      new FollowToggle(followButton, {\n        userId: user.id,\n        followState: user.followed ? 'followed' : 'unfollowed'\n      });\n      // a.append(followButton);\n      li.append(a);\n      this.ul.append(li);\n    });\n  }\n}\n\n\n\n// Now, let's set up your controller to respond to AJAX requests with JSON. Because your \n// controller will be handling both HTML and JSON requests, let's separate out each of those \n// types of requests and respond to them separately. Put the following code into your \n// controller to replace the line reading render :search:\n\n\nmodule.exports = UsersSearch; \n\n\n//////////////////\n// WEBPACK FOOTER\n// ./frontend/users_search.js\n// module id = 2\n// module chunks = 0","\nclass TweetCompose {\n\tconstructor(el){\n\t\tthis.el = $(el);\n\t\tthis.post = this.el.find('[name=\"tweet[content]\"]');\n\n\t\tthis.post.on(\"input\", this.handleInput.bind(this));\n\n\n\t\tthis.el.on(\"submit\", this.submit.bind(this));\n\t}\n\n// Finally, let's add a counter that will show the number of characters remaining \n// for a tweet (starting at 140). Add a strong tag with class .chars-left to the \n// form. In the TweetCompose constructor, add an input event handler on the \n// textarea. In it, update the strong tag with the number of characters remaining.\n\n\n\thandleInput(event){\n\t\tconst tweetLength = this.post.val().length;\n\t\tif (tweetLength > 140){\n\t\t\tthis.el.find(\".chars-left\").html(`Post too long by ${tweetLength-140} characters!`)\n\t\t} else{\n\t\tthis.el.find(\".chars-left\").html(`Characters remaining: ${140-tweetLength}`);\n\t\t\t\n\t\t}\n\t}\n\n\n// In the TweetCompose constructor, install a submit event handler. Write a \n// TweetCompose#submit method that uses serializeJSON to build JSON from the form \n// contents and use $.ajax to submit the form.\n\n// As before, disable the form when the submit is made. You can't disable an \n// entire form, so you'll have to disable all the inputs. To get all the inputs, \n// use jQuery's :input pseudo-CSS selector. Make sure not to disable your inputs \n// until after you've serialized the form contents, or their values will be \n// ignored. :(\n\n\tsubmit(event){\n\t\tevent.preventDefault();\n\n\t\tconst data = this.el.serializeJSON(); // serialize the form contents first\n\t\tthis.el.find(\":input\").prop(\"disabled\", true); \n\n\t\t$.ajax({\n\t\t\turl: '/tweets',\n\t\t\tdataType: 'json',\n\t\t\tmethod: 'POST',\n\t\t\tdata: data,\n\t\t\tsuccess: this.handleSuccess.bind(this)\n\t\t})\n\t}\n\n// Write a TweetCompose#clearInput method to empty out all the inputs after a \n// tweet is successfully created. \n\n\tclearInput(){\n\n\t}\n\n\t// Write a TweetCompose#handleSuccess method. This \n// should call clearInput and re-enable the form.\n\n// In #handleSuccess, we also want to insert the created tweet into the list of \n// all tweets. How does TweetCompose find the ul of tweets? We can set a data \n// attribute on the form where the value is the selector that corresponds to the \n// target ul. For example, if we give the target ul an id of #feed, we can give \n// our form the following data attribute: data-tweets-ul=\"#feed\". Our TweetCompose \n// can pull out this data attribute and use the selector #feed to find the ul. \n// This is better than hard coding #feed into the JS.\n\thandleSuccess(){\n\n\t\tthis.clearInput();\n\t}\n\n}\n\n\n\n\n\n// A successful AJAX post request for a tweet should return back the newly created \n// tweet in JSON format. For simplicity, have TweetCompose call JSON.stringify on \n// the created Tweet. Build an li with the JSON content, and stick it in the ul. \n// We'll actually render this nicely in a later phase.\n\n\nmodule.exports = TweetCompose;\n\n\n//////////////////\n// WEBPACK FOOTER\n// ./frontend/tweet_compose.js\n// module id = 3\n// module chunks = 0"],"sourceRoot":""}